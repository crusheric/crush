"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "buildSearchParam", {
    enumerable: true,
    get: function() {
        return buildSearchParam;
    }
});
const _bsonobjectid = /*#__PURE__*/ _interop_require_default(require("bson-objectid"));
const _mongoose = /*#__PURE__*/ _interop_require_default(require("mongoose"));
const _database = require("payload/database");
const _types = require("payload/types");
const _operatorMap = require("./operatorMap");
const _sanitizeQueryValue = require("./sanitizeQueryValue");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const subQueryOptions = {
    lean: true,
    limit: 50
};
async function buildSearchParam({ collectionSlug, fields, globalSlug, incomingPath, locale, operator, payload, val }) {
    // Replace GraphQL nested field double underscore formatting
    let sanitizedPath = incomingPath.replace(/__/g, '.');
    if (sanitizedPath === 'id') sanitizedPath = '_id';
    let paths = [];
    let hasCustomID = false;
    if (sanitizedPath === '_id') {
        const customIDfield = payload.collections[collectionSlug]?.config.fields.find((field)=>(0, _types.fieldAffectsData)(field) && field.name === 'id');
        let idFieldType = 'text';
        if (customIDfield) {
            if (customIDfield?.type === 'text' || customIDfield?.type === 'number') {
                idFieldType = customIDfield.type;
            }
            hasCustomID = true;
        }
        paths.push({
            collectionSlug,
            complete: true,
            field: {
                name: 'id',
                type: idFieldType
            },
            path: '_id'
        });
    } else {
        paths = await (0, _database.getLocalizedPaths)({
            collectionSlug,
            fields,
            globalSlug,
            incomingPath: sanitizedPath,
            locale,
            payload
        });
    }
    const [{ field, path }] = paths;
    if (path) {
        const { operator: formattedOperator, rawQuery, val: formattedValue } = (0, _sanitizeQueryValue.sanitizeQueryValue)({
            field,
            hasCustomID,
            operator,
            path,
            val
        });
        if (rawQuery) return {
            value: rawQuery
        };
        // If there are multiple collections to search through,
        // Recursively build up a list of query constraints
        if (paths.length > 1) {
            // Remove top collection and reverse array
            // to work backwards from top
            const pathsToQuery = paths.slice(1).reverse();
            const initialRelationshipQuery = {
                value: {}
            };
            const relationshipQuery = await pathsToQuery.reduce(async (priorQuery, { collectionSlug: slug, path: subPath }, i)=>{
                const priorQueryResult = await priorQuery;
                const SubModel = payload.db.collections[slug];
                // On the "deepest" collection,
                // Search on the value passed through the query
                if (i === 0) {
                    const subQuery = await SubModel.buildQuery({
                        locale,
                        payload,
                        where: {
                            [subPath]: {
                                [formattedOperator]: val
                            }
                        }
                    });
                    const result = await SubModel.find(subQuery, subQueryOptions);
                    const $in = [];
                    result.forEach((doc)=>{
                        const stringID = doc._id.toString();
                        $in.push(stringID);
                        if (_mongoose.default.Types.ObjectId.isValid(stringID)) {
                            $in.push(doc._id);
                        }
                    });
                    if (pathsToQuery.length === 1) {
                        return {
                            path,
                            value: {
                                $in
                            }
                        };
                    }
                    const nextSubPath = pathsToQuery[i + 1].path;
                    return {
                        value: {
                            [nextSubPath]: {
                                $in
                            }
                        }
                    };
                }
                const subQuery = priorQueryResult.value;
                const result = await SubModel.find(subQuery, subQueryOptions);
                const $in = result.map((doc)=>doc._id.toString());
                // If it is the last recursion
                // then pass through the search param
                if (i + 1 === pathsToQuery.length) {
                    return {
                        path,
                        value: {
                            $in
                        }
                    };
                }
                return {
                    value: {
                        _id: {
                            $in
                        }
                    }
                };
            }, Promise.resolve(initialRelationshipQuery));
            return relationshipQuery;
        }
        if (formattedOperator && _types.validOperators.includes(formattedOperator)) {
            const operatorKey = _operatorMap.operatorMap[formattedOperator];
            if (field.type === 'relationship' || field.type === 'upload') {
                let hasNumberIDRelation;
                const result = {
                    value: {
                        $or: [
                            {
                                [path]: {
                                    [operatorKey]: formattedValue
                                }
                            }
                        ]
                    }
                };
                if (typeof formattedValue === 'string') {
                    if (_mongoose.default.Types.ObjectId.isValid(formattedValue)) {
                        result.value.$or.push({
                            [path]: {
                                [operatorKey]: (0, _bsonobjectid.default)(formattedValue)
                            }
                        });
                    } else {
                        (Array.isArray(field.relationTo) ? field.relationTo : [
                            field.relationTo
                        ]).forEach((relationTo)=>{
                            const isRelatedToCustomNumberID = payload.collections[relationTo]?.config?.fields.find((relatedField)=>{
                                return (0, _types.fieldAffectsData)(relatedField) && relatedField.name === 'id' && relatedField.type === 'number';
                            });
                            if (isRelatedToCustomNumberID) {
                                if (isRelatedToCustomNumberID.type === 'number') hasNumberIDRelation = true;
                            }
                        });
                        if (hasNumberIDRelation) result.value.$or.push({
                            [path]: {
                                [operatorKey]: parseFloat(formattedValue)
                            }
                        });
                    }
                }
                if (result.value.$or.length > 1) {
                    return result;
                }
            }
            if (formattedOperator === 'like' && typeof formattedValue === 'string') {
                const words = formattedValue.split(' ');
                const result = {
                    value: {
                        $and: words.map((word)=>({
                                [path]: {
                                    $options: 'i',
                                    $regex: word.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
                                }
                            }))
                    }
                };
                return result;
            }
            // Some operators like 'near' need to define a full query
            // so if there is no operator key, just return the value
            if (!operatorKey) {
                return {
                    path,
                    value: formattedValue
                };
            }
            return {
                path,
                value: {
                    [operatorKey]: formattedValue
                }
            };
        }
    }
    return undefined;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyaWVzL2J1aWxkU2VhcmNoUGFyYW1zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUGF5bG9hZCB9IGZyb20gJ3BheWxvYWQnXG5pbXBvcnQgdHlwZSB7IFBhdGhUb1F1ZXJ5IH0gZnJvbSAncGF5bG9hZC9kYXRhYmFzZSdcbmltcG9ydCB0eXBlIHsgRmllbGQgfSBmcm9tICdwYXlsb2FkL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBPcGVyYXRvciB9IGZyb20gJ3BheWxvYWQvdHlwZXMnXG5cbmltcG9ydCBvYmplY3RJRCBmcm9tICdic29uLW9iamVjdGlkJ1xuaW1wb3J0IG1vbmdvb3NlIGZyb20gJ21vbmdvb3NlJ1xuaW1wb3J0IHsgZ2V0TG9jYWxpemVkUGF0aHMgfSBmcm9tICdwYXlsb2FkL2RhdGFiYXNlJ1xuaW1wb3J0IHsgZmllbGRBZmZlY3RzRGF0YSB9IGZyb20gJ3BheWxvYWQvdHlwZXMnXG5pbXBvcnQgeyB2YWxpZE9wZXJhdG9ycyB9IGZyb20gJ3BheWxvYWQvdHlwZXMnXG5cbmltcG9ydCB0eXBlIHsgTW9uZ29vc2VBZGFwdGVyIH0gZnJvbSAnLi4nXG5cbmltcG9ydCB7IG9wZXJhdG9yTWFwIH0gZnJvbSAnLi9vcGVyYXRvck1hcCdcbmltcG9ydCB7IHNhbml0aXplUXVlcnlWYWx1ZSB9IGZyb20gJy4vc2FuaXRpemVRdWVyeVZhbHVlJ1xuXG50eXBlIFNlYXJjaFBhcmFtID0ge1xuICBwYXRoPzogc3RyaW5nXG4gIHJhd1F1ZXJ5PzogdW5rbm93blxuICB2YWx1ZT86IHVua25vd25cbn1cblxuY29uc3Qgc3ViUXVlcnlPcHRpb25zID0ge1xuICBsZWFuOiB0cnVlLFxuICBsaW1pdDogNTAsXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgUGF5bG9hZCBrZXkgLyB2YWx1ZSAvIG9wZXJhdG9yIGludG8gYSBNb25nb0RCIHF1ZXJ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFNlYXJjaFBhcmFtKHtcbiAgY29sbGVjdGlvblNsdWcsXG4gIGZpZWxkcyxcbiAgZ2xvYmFsU2x1ZyxcbiAgaW5jb21pbmdQYXRoLFxuICBsb2NhbGUsXG4gIG9wZXJhdG9yLFxuICBwYXlsb2FkLFxuICB2YWwsXG59OiB7XG4gIGNvbGxlY3Rpb25TbHVnPzogc3RyaW5nXG4gIGZpZWxkczogRmllbGRbXVxuICBnbG9iYWxTbHVnPzogc3RyaW5nXG4gIGluY29taW5nUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xuICBvcGVyYXRvcjogc3RyaW5nXG4gIHBheWxvYWQ6IFBheWxvYWRcbiAgdmFsOiB1bmtub3duXG59KTogUHJvbWlzZTxTZWFyY2hQYXJhbT4ge1xuICAvLyBSZXBsYWNlIEdyYXBoUUwgbmVzdGVkIGZpZWxkIGRvdWJsZSB1bmRlcnNjb3JlIGZvcm1hdHRpbmdcbiAgbGV0IHNhbml0aXplZFBhdGggPSBpbmNvbWluZ1BhdGgucmVwbGFjZSgvX18vZywgJy4nKVxuICBpZiAoc2FuaXRpemVkUGF0aCA9PT0gJ2lkJykgc2FuaXRpemVkUGF0aCA9ICdfaWQnXG5cbiAgbGV0IHBhdGhzOiBQYXRoVG9RdWVyeVtdID0gW11cblxuICBsZXQgaGFzQ3VzdG9tSUQgPSBmYWxzZVxuXG4gIGlmIChzYW5pdGl6ZWRQYXRoID09PSAnX2lkJykge1xuICAgIGNvbnN0IGN1c3RvbUlEZmllbGQgPSBwYXlsb2FkLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25TbHVnXT8uY29uZmlnLmZpZWxkcy5maW5kKFxuICAgICAgKGZpZWxkKSA9PiBmaWVsZEFmZmVjdHNEYXRhKGZpZWxkKSAmJiBmaWVsZC5uYW1lID09PSAnaWQnLFxuICAgIClcblxuICAgIGxldCBpZEZpZWxkVHlwZTogJ251bWJlcicgfCAndGV4dCcgPSAndGV4dCdcblxuICAgIGlmIChjdXN0b21JRGZpZWxkKSB7XG4gICAgICBpZiAoY3VzdG9tSURmaWVsZD8udHlwZSA9PT0gJ3RleHQnIHx8IGN1c3RvbUlEZmllbGQ/LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlkRmllbGRUeXBlID0gY3VzdG9tSURmaWVsZC50eXBlXG4gICAgICB9XG5cbiAgICAgIGhhc0N1c3RvbUlEID0gdHJ1ZVxuICAgIH1cblxuICAgIHBhdGhzLnB1c2goe1xuICAgICAgY29sbGVjdGlvblNsdWcsXG4gICAgICBjb21wbGV0ZTogdHJ1ZSxcbiAgICAgIGZpZWxkOiB7XG4gICAgICAgIG5hbWU6ICdpZCcsXG4gICAgICAgIHR5cGU6IGlkRmllbGRUeXBlLFxuICAgICAgfSBhcyBGaWVsZCxcbiAgICAgIHBhdGg6ICdfaWQnLFxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcGF0aHMgPSBhd2FpdCBnZXRMb2NhbGl6ZWRQYXRocyh7XG4gICAgICBjb2xsZWN0aW9uU2x1ZyxcbiAgICAgIGZpZWxkcyxcbiAgICAgIGdsb2JhbFNsdWcsXG4gICAgICBpbmNvbWluZ1BhdGg6IHNhbml0aXplZFBhdGgsXG4gICAgICBsb2NhbGUsXG4gICAgICBwYXlsb2FkLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCBbeyBmaWVsZCwgcGF0aCB9XSA9IHBhdGhzXG5cbiAgaWYgKHBhdGgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRvcjogZm9ybWF0dGVkT3BlcmF0b3IsXG4gICAgICByYXdRdWVyeSxcbiAgICAgIHZhbDogZm9ybWF0dGVkVmFsdWUsXG4gICAgfSA9IHNhbml0aXplUXVlcnlWYWx1ZSh7XG4gICAgICBmaWVsZCxcbiAgICAgIGhhc0N1c3RvbUlELFxuICAgICAgb3BlcmF0b3IsXG4gICAgICBwYXRoLFxuICAgICAgdmFsLFxuICAgIH0pXG5cbiAgICBpZiAocmF3UXVlcnkpIHJldHVybiB7IHZhbHVlOiByYXdRdWVyeSB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29sbGVjdGlvbnMgdG8gc2VhcmNoIHRocm91Z2gsXG4gICAgLy8gUmVjdXJzaXZlbHkgYnVpbGQgdXAgYSBsaXN0IG9mIHF1ZXJ5IGNvbnN0cmFpbnRzXG4gICAgaWYgKHBhdGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFJlbW92ZSB0b3AgY29sbGVjdGlvbiBhbmQgcmV2ZXJzZSBhcnJheVxuICAgICAgLy8gdG8gd29yayBiYWNrd2FyZHMgZnJvbSB0b3BcbiAgICAgIGNvbnN0IHBhdGhzVG9RdWVyeSA9IHBhdGhzLnNsaWNlKDEpLnJldmVyc2UoKVxuXG4gICAgICBjb25zdCBpbml0aWFsUmVsYXRpb25zaGlwUXVlcnkgPSB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgIH0gYXMgU2VhcmNoUGFyYW1cblxuICAgICAgY29uc3QgcmVsYXRpb25zaGlwUXVlcnkgPSBhd2FpdCBwYXRoc1RvUXVlcnkucmVkdWNlKFxuICAgICAgICBhc3luYyAocHJpb3JRdWVyeSwgeyBjb2xsZWN0aW9uU2x1Zzogc2x1ZywgcGF0aDogc3ViUGF0aCB9LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJpb3JRdWVyeVJlc3VsdCA9IGF3YWl0IHByaW9yUXVlcnlcblxuICAgICAgICAgIGNvbnN0IFN1Yk1vZGVsID0gKHBheWxvYWQuZGIgYXMgTW9uZ29vc2VBZGFwdGVyKS5jb2xsZWN0aW9uc1tzbHVnXVxuXG4gICAgICAgICAgLy8gT24gdGhlIFwiZGVlcGVzdFwiIGNvbGxlY3Rpb24sXG4gICAgICAgICAgLy8gU2VhcmNoIG9uIHRoZSB2YWx1ZSBwYXNzZWQgdGhyb3VnaCB0aGUgcXVlcnlcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViUXVlcnkgPSBhd2FpdCBTdWJNb2RlbC5idWlsZFF1ZXJ5KHtcbiAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgIFtzdWJQYXRoXToge1xuICAgICAgICAgICAgICAgICAgW2Zvcm1hdHRlZE9wZXJhdG9yXTogdmFsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdWJNb2RlbC5maW5kKHN1YlF1ZXJ5LCBzdWJRdWVyeU9wdGlvbnMpXG5cbiAgICAgICAgICAgIGNvbnN0ICRpbjogdW5rbm93bltdID0gW11cblxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJRCA9IGRvYy5faWQudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAkaW4ucHVzaChzdHJpbmdJRClcblxuICAgICAgICAgICAgICBpZiAobW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQuaXNWYWxpZChzdHJpbmdJRCkpIHtcbiAgICAgICAgICAgICAgICAkaW4ucHVzaChkb2MuX2lkKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAocGF0aHNUb1F1ZXJ5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHsgJGluIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbmV4dFN1YlBhdGggPSBwYXRoc1RvUXVlcnlbaSArIDFdLnBhdGhcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHsgW25leHRTdWJQYXRoXTogeyAkaW4gfSB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN1YlF1ZXJ5ID0gcHJpb3JRdWVyeVJlc3VsdC52YWx1ZVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN1Yk1vZGVsLmZpbmQoc3ViUXVlcnksIHN1YlF1ZXJ5T3B0aW9ucylcblxuICAgICAgICAgIGNvbnN0ICRpbiA9IHJlc3VsdC5tYXAoKGRvYykgPT4gZG9jLl9pZC50b1N0cmluZygpKVxuXG4gICAgICAgICAgLy8gSWYgaXQgaXMgdGhlIGxhc3QgcmVjdXJzaW9uXG4gICAgICAgICAgLy8gdGhlbiBwYXNzIHRocm91Z2ggdGhlIHNlYXJjaCBwYXJhbVxuICAgICAgICAgIGlmIChpICsgMSA9PT0gcGF0aHNUb1F1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgdmFsdWU6IHsgJGluIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIF9pZDogeyAkaW4gfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFJlbGF0aW9uc2hpcFF1ZXJ5KSxcbiAgICAgIClcblxuICAgICAgcmV0dXJuIHJlbGF0aW9uc2hpcFF1ZXJ5XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdHRlZE9wZXJhdG9yICYmIHZhbGlkT3BlcmF0b3JzLmluY2x1ZGVzKGZvcm1hdHRlZE9wZXJhdG9yIGFzIE9wZXJhdG9yKSkge1xuICAgICAgY29uc3Qgb3BlcmF0b3JLZXkgPSBvcGVyYXRvck1hcFtmb3JtYXR0ZWRPcGVyYXRvcl1cblxuICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdyZWxhdGlvbnNoaXAnIHx8IGZpZWxkLnR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgICAgIGxldCBoYXNOdW1iZXJJRFJlbGF0aW9uXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAkb3I6IFt7IFtwYXRoXTogeyBbb3BlcmF0b3JLZXldOiBmb3JtYXR0ZWRWYWx1ZSB9IH1dLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChtb25nb29zZS5UeXBlcy5PYmplY3RJZC5pc1ZhbGlkKGZvcm1hdHRlZFZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlLiRvci5wdXNoKHsgW3BhdGhdOiB7IFtvcGVyYXRvcktleV06IG9iamVjdElEKGZvcm1hdHRlZFZhbHVlKSB9IH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIDsoQXJyYXkuaXNBcnJheShmaWVsZC5yZWxhdGlvblRvKSA/IGZpZWxkLnJlbGF0aW9uVG8gOiBbZmllbGQucmVsYXRpb25Ub10pLmZvckVhY2goXG4gICAgICAgICAgICAgIChyZWxhdGlvblRvKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWxhdGVkVG9DdXN0b21OdW1iZXJJRCA9IHBheWxvYWQuY29sbGVjdGlvbnNbXG4gICAgICAgICAgICAgICAgICByZWxhdGlvblRvXG4gICAgICAgICAgICAgICAgXT8uY29uZmlnPy5maWVsZHMuZmluZCgocmVsYXRlZEZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBmaWVsZEFmZmVjdHNEYXRhKHJlbGF0ZWRGaWVsZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEZpZWxkLm5hbWUgPT09ICdpZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEZpZWxkLnR5cGUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF0ZWRUb0N1c3RvbU51bWJlcklEKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNSZWxhdGVkVG9DdXN0b21OdW1iZXJJRC50eXBlID09PSAnbnVtYmVyJykgaGFzTnVtYmVySURSZWxhdGlvbiA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmIChoYXNOdW1iZXJJRFJlbGF0aW9uKVxuICAgICAgICAgICAgICByZXN1bHQudmFsdWUuJG9yLnB1c2goeyBbcGF0aF06IHsgW29wZXJhdG9yS2V5XTogcGFyc2VGbG9hdChmb3JtYXR0ZWRWYWx1ZSkgfSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUuJG9yLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1hdHRlZE9wZXJhdG9yID09PSAnbGlrZScgJiYgdHlwZW9mIGZvcm1hdHRlZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB3b3JkcyA9IGZvcm1hdHRlZFZhbHVlLnNwbGl0KCcgJylcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICRhbmQ6IHdvcmRzLm1hcCgod29yZCkgPT4gKHtcbiAgICAgICAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgICAgICAgJG9wdGlvbnM6ICdpJyxcbiAgICAgICAgICAgICAgICAkcmVnZXg6IHdvcmQucmVwbGFjZSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICAvLyBTb21lIG9wZXJhdG9ycyBsaWtlICduZWFyJyBuZWVkIHRvIGRlZmluZSBhIGZ1bGwgcXVlcnlcbiAgICAgIC8vIHNvIGlmIHRoZXJlIGlzIG5vIG9wZXJhdG9yIGtleSwganVzdCByZXR1cm4gdGhlIHZhbHVlXG4gICAgICBpZiAoIW9wZXJhdG9yS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdmFsdWU6IHsgW29wZXJhdG9yS2V5XTogZm9ybWF0dGVkVmFsdWUgfSxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuIl0sIm5hbWVzIjpbImJ1aWxkU2VhcmNoUGFyYW0iLCJzdWJRdWVyeU9wdGlvbnMiLCJsZWFuIiwibGltaXQiLCJjb2xsZWN0aW9uU2x1ZyIsImZpZWxkcyIsImdsb2JhbFNsdWciLCJpbmNvbWluZ1BhdGgiLCJsb2NhbGUiLCJvcGVyYXRvciIsInBheWxvYWQiLCJ2YWwiLCJzYW5pdGl6ZWRQYXRoIiwicmVwbGFjZSIsInBhdGhzIiwiaGFzQ3VzdG9tSUQiLCJjdXN0b21JRGZpZWxkIiwiY29sbGVjdGlvbnMiLCJjb25maWciLCJmaW5kIiwiZmllbGQiLCJmaWVsZEFmZmVjdHNEYXRhIiwibmFtZSIsImlkRmllbGRUeXBlIiwidHlwZSIsInB1c2giLCJjb21wbGV0ZSIsInBhdGgiLCJnZXRMb2NhbGl6ZWRQYXRocyIsImZvcm1hdHRlZE9wZXJhdG9yIiwicmF3UXVlcnkiLCJmb3JtYXR0ZWRWYWx1ZSIsInNhbml0aXplUXVlcnlWYWx1ZSIsInZhbHVlIiwibGVuZ3RoIiwicGF0aHNUb1F1ZXJ5Iiwic2xpY2UiLCJyZXZlcnNlIiwiaW5pdGlhbFJlbGF0aW9uc2hpcFF1ZXJ5IiwicmVsYXRpb25zaGlwUXVlcnkiLCJyZWR1Y2UiLCJwcmlvclF1ZXJ5Iiwic2x1ZyIsInN1YlBhdGgiLCJpIiwicHJpb3JRdWVyeVJlc3VsdCIsIlN1Yk1vZGVsIiwiZGIiLCJzdWJRdWVyeSIsImJ1aWxkUXVlcnkiLCJ3aGVyZSIsInJlc3VsdCIsIiRpbiIsImZvckVhY2giLCJkb2MiLCJzdHJpbmdJRCIsIl9pZCIsInRvU3RyaW5nIiwibW9uZ29vc2UiLCJUeXBlcyIsIk9iamVjdElkIiwiaXNWYWxpZCIsIm5leHRTdWJQYXRoIiwibWFwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ2YWxpZE9wZXJhdG9ycyIsImluY2x1ZGVzIiwib3BlcmF0b3JLZXkiLCJvcGVyYXRvck1hcCIsImhhc051bWJlcklEUmVsYXRpb24iLCIkb3IiLCJvYmplY3RJRCIsIkFycmF5IiwiaXNBcnJheSIsInJlbGF0aW9uVG8iLCJpc1JlbGF0ZWRUb0N1c3RvbU51bWJlcklEIiwicmVsYXRlZEZpZWxkIiwicGFyc2VGbG9hdCIsIndvcmRzIiwic3BsaXQiLCIkYW5kIiwid29yZCIsIiRvcHRpb25zIiwiJHJlZ2V4IiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7OytCQThCc0JBOzs7ZUFBQUE7OztxRUF6QkQ7aUVBQ0E7MEJBQ2E7dUJBQ0Q7NkJBS0w7b0NBQ087Ozs7OztBQVFuQyxNQUFNQyxrQkFBa0I7SUFDdEJDLE1BQU07SUFDTkMsT0FBTztBQUNUO0FBS08sZUFBZUgsaUJBQWlCLEVBQ3JDSSxjQUFjLEVBQ2RDLE1BQU0sRUFDTkMsVUFBVSxFQUNWQyxZQUFZLEVBQ1pDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxPQUFPLEVBQ1BDLEdBQUcsRUFVSjtJQUNDLDREQUE0RDtJQUM1RCxJQUFJQyxnQkFBZ0JMLGFBQWFNLE9BQU8sQ0FBQyxPQUFPO0lBQ2hELElBQUlELGtCQUFrQixNQUFNQSxnQkFBZ0I7SUFFNUMsSUFBSUUsUUFBdUIsRUFBRTtJQUU3QixJQUFJQyxjQUFjO0lBRWxCLElBQUlILGtCQUFrQixPQUFPO1FBQzNCLE1BQU1JLGdCQUFnQk4sUUFBUU8sV0FBVyxDQUFDYixlQUFlLEVBQUVjLE9BQU9iLE9BQU9jLEtBQ3ZFLENBQUNDLFFBQVVDLElBQUFBLHVCQUFnQixFQUFDRCxVQUFVQSxNQUFNRSxJQUFJLEtBQUs7UUFHdkQsSUFBSUMsY0FBaUM7UUFFckMsSUFBSVAsZUFBZTtZQUNqQixJQUFJQSxlQUFlUSxTQUFTLFVBQVVSLGVBQWVRLFNBQVMsVUFBVTtnQkFDdEVELGNBQWNQLGNBQWNRLElBQUk7WUFD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